# введение в git
Распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года.<https://ru.wikipedia.org/wiki/Git>
![git](git.png)


## Создание репозитория
### создание репозитория
для создания репозитория можно использовать комманду **git init**
```
$ git init
```
при этом необходимо находится в каталоге с проектом иначе папка будет создана в корневом каталоге.


### добавление файлов
По умолчанию коммиты добавляются в ветку мастер.
добавление файлов происходит командой
`git add`
```
$ git add '.\file.md'
```
при этом файл индексируется и становится в ожидание. Для добавдения его в **git** необходимо создать первый коммит. после чего файл будет отображаться при помощи команды **git show** а история его изменения при помощи команды  **git log**

### Коммиты в git

Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит в набор изменений или «дельту» между текущей версией и предыдущей. Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом! для простоты будем считать их полными снимками проекта.
Для создания коммита воспользуйтесь командой
```
$ git commit
```
при этом откроется текстовый редактор для добавления информации о комите.
Можно использовать команду
```
$ git commit -m "описание коммита"
```
тогда название коммиту будет присвоено сразу

### просмотр информации о состояние репозитории
для просмотра последнего коммита необходимо воспользоваться командой **git show**
```
$ git show
```
для просмотра всей истории изменений коммитов необходимо воспользоваться **git log**
```
$ git log
```
что бы посмотреть текущее состояние репозитория, наличие новых файлов или незарегестрированны изменений в них, а так же ветку в который вы находитесь воспользуйтесь **git status**
```
$ git status
```

# Ветвление в Git

## Создание ветки
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.
Чуть позже мы попробуем использовать ветки и коммиты, и вы увидите, как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущего коммита и всех его родителей.
```
`git branch name`
```
## Удаление ветки
Для удаления ветки выполните команду `git branch` с параметром `-d`:
```console
$ git branch -d name
Deleted branch name ( ).
```
## Перемещение ветки
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции `-f`. Например, команда:
```
`git branch -f main HEAD~3`
```
Переместит (принудительно) ветку `main` на три родителя назад от `HEAD`. или вместо `HEAD` необходимо указать название ветки
## Ветки и слияния

Слияние важнейшая часть работы с git.
Мы уже знаем, как создавать ветки и коммитить наши изменения. Теперь надо понять, как объединять изменения из двух разных веток. Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими.

### Git Merge
объединения изменений, который мы рассмотрим - это `git merge` - слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами.
### Git Rebase
Второй способ объединения изменений в ветках - это _rebasing_. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место. Несмотря на то, что это звучит достаточно непонятно, преимущество `rebase` в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете `rebase`.
```
`git rebase main`
```
тогда копия будет сделана в место HEAD.
можно использовать команду в таком формате
```
`git rebase main bugFix`
```
В таком случае ветка *bugFix* будет присоединена к ветке *main* вне зависимости от положения *HEAD*.

# работа с удаленными репозиториями

## Как подключиться к удаленному репозитарию?


Для загрузки данных в удаленный репозитарию сначала нужно к нему подключиться. В нашем примере мы используем адрес https://github.com/tutorialzine/awesome-project, однако пользователь может создать собственный удаленный репозитарий на GitHub, BitBucket или другом подобном сервисе. Это занимает некоторое время, однако в дальнейшем полностью себя оправдывает, тем более, что подобные службы имеют пошаговые инструкции для правильно выполнения нужных действий.



Для того, чтобы связать созданный нами локальный репозитарий с удаленным, выполним такую команду:

```
# This is only an example. Replace the URI with your own repository address.
$ git remote add origin https://github.com/tutorialzine/awesome-project.git
```

Первая строка напоминает нам, что URI репозитария, который приведен в примере, нужно изменить на свой.
Иногда бывает так, что проект имеет несколько удаленных репозитариев – в таком случае каждому из них присваивается собственное имя. Главный репозитарий принято называть origin

## Как отправить изменения в удаленный репозитарий?


Теперь, когда у нас в локальном репозитарии создан коммит и мы подключились к удаленному, можем отправить его на сервер. Мы это будем делать каждый раз, когда хотим обновить данные в удаленном репозитарии.



Отправка коммита осуществляется с помощью команды push, которая имеет два параметра - имя удаленного репозитория (в нашем случае origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).
```
$ git push origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/tutorialzine/awesome-project.git
* [new branch] master -> master
```

Если мы все сделали правильно, то отправленный файл hello.txt на удаленном сервере мы можем увидеть с помощью браузера. Важный момент – некоторые сервисы для отправки изменений могут требовать дополнительной аутентификации.

## Как клонировать удаленный репозитарий?


Если у других пользователей возникла необходимость клонировать удаленный репозитарий, они могут получить полностью работоспособную копию при помощи команды clone:

```
$ git clone https://github.com/tutorialzine/awesome-project.git
```

GitHub автоматически создаст новый локальный репозитарий в виде удаленного на собственном сервере.


## Как запросить изменения с удаленного репозитария?

В случае, если другим пользователям нет необходимости делать клон удаленного репозитария, а нужно просто получить информацию об изменениях, это можно сделать с помощью команды pull:
```
$ git pull origin master
From https://github.com/tutorialzine/awesome-project
* branch master -> FETCH_HEAD
Already up-to-date.
```
Она скачивает новые изменения. Так как мы ничего нового не вносили с тех пор, как клонировали проект, изменений, доступных к скачиванию, нет.
